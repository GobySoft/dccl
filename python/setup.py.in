#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""Setuptools build script for DCCL Bindings."""
__author__ = "Chris Murphy, Toby Schneider"
__copyright__ = "Copyright 2018-2019, The DCCL Project"
__license__ = "LGPL"

from setuptools import setup, find_packages
from setuptools.extension import Extension
from distutils.command.clean import clean as _clean
from distutils.command.build_py import build_py as _build_py
from distutils.command.build_ext import build_ext as _build_ext
import subprocess
import os, sys
import time
from shutil import rmtree

# enforce use of the same compiler as CMake is set to 
os.environ["CC"]='@CMAKE_C_COMPILER@'
os.environ["CXX"]='@CMAKE_CXX_COMPILER@'

build_host="@CMAKE_HOST_SYSTEM_PROCESSOR@"
build_target="@CMAKE_SYSTEM_PROCESSOR@"

def get_version():
  # Resolves a PEP 440 warning for invalid versions when, e.g., version is 4.0.0~alpha0.
  return open('@CMAKE_SOURCE_DIR@/version.txt', 'r').readline().strip().split('~')[0]

class clean(_clean):
  def run(self):
    # Delete generated files in the code tree.
    for (dirpath, dirnames, filenames) in os.walk("."):
      for filename in filenames:
        filepath = os.path.join(dirpath, filename)
        if filepath.endswith("_pb2.py") or filepath.endswith(".pyc") or \
          filepath.endswith(".so") or filepath.endswith(".o"):
          os.remove(filepath)
    rmtree("dccl.egg-info")
    # _clean is an old-style class, so super() doesn't work.
    _clean.run(self)

class build_py(_build_py):
  def run(self):
    # Generate option_extension.proto file.
    protoc_command = ['protoc', '-I@dccl_INC_DIR@/', '-I/usr/include', '--python_out=.', '@dccl_INC_DIR@/dccl/option_extensions.proto']
    if subprocess.call(protoc_command) != 0:
      sys.exit(-1)

    # _build_py is an old-style class, so super() doesn't work.
    _build_py.run(self)

# override the filename generated by setuptools as this is hardcoded to the build arch value
# and must be changed for cross-compiling
class build_ext(_build_ext):
    def get_ext_filename(self, ext_name):      
      filename = super().get_ext_filename(ext_name)      
      # Replace the build architecture with the target architecture
      filename = filename.replace(build_host, build_target)
      return filename    
    
setup(
    name="dccl",
    version=get_version(),
    description="Python Bindings for DCCL.",
    author="Chris Murphy",
    author_email="cmurphy@aphysci.com",

    packages=find_packages(),

    ext_modules = [
        Extension(
            "dccl._dccl",
            ["dccl/_dccl.cc"],
            libraries=['dccl', 'protobuf'],
            include_dirs=['@dccl_INC_DIR@'],
            library_dirs=['@dccl_LIB_DIR@'],
            extra_compile_args = ["-Wno-write-strings", "-std=c++@CMAKE_CXX_STANDARD@"], # Hide a bunch of c++ warnings.
        )
    ],

    # Override clean + build to support protobuf.
    cmdclass={
      'clean': clean,
      'build_py': build_py,
      'build_ext': build_ext
    }

)

